<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        font-family: sans-serif;
        margin: 0;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      header {
        padding: 0.5em;
        background: #eee;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5em;
        align-items: center;
      }

      header h2, header h3 {
        margin: 0.2em 0;
        flex-basis: 100%;
      }

      main {
        flex: 1;
        display: flex;
        flex-wrap: wrap;
        overflow: hidden;
      }

      aside {
        flex: 0 0 150px;
        padding: 0.5em;
        background: #f5f5f5;
        overflow-y: auto;
        min-width: 120px;
      }

      textarea {
        flex: 1 1 300px;
        padding: 0.5em;
        font-family: monospace;
        resize: both;
        min-width: 150px;
        min-height: 150px;
        box-sizing: border-box;
      }

      .preview-container {
        flex: 1 1 300px;
        border: 1px solid #ccc;
        position: relative;
        min-height: 150px;
        display: flex;
        flex-direction: column;
      }

      iframe {
        width: 100%;
        height: 100%;
        border: none;
        flex: 1;
      }

      button {
        padding: 0.3em 0.5em;
      }

      .saved-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 0.2em 0;
      }

      .saved-item button {
        flex: 1;
        margin-right: 0.2em;
      }

      .delete-btn {
        flex: 0;
        background: #ff0000;
        color: white;
        border: solid black;
        cursor: pointer;
        padding: 0 0.4em;
      }

      .fullscreen {
        position: fixed !important;
        top: 0;
        left: 0;
        width: 100% !important;
        height: 100% !important;
        z-index: 9999;
        background: #fff;
        display: flex;
        flex-direction: column;
      }

      .back-btn {
        position: absolute;
        top: 0px;
        left: 0px;
        font-size: 10px;
        padding: 2px 5px;
        z-index: 10000;
        display: none;
      }

      .fullscreen .back-btn {
        display: block;
      }

      #exitSnippetBtn {
        display: none;
        background: #444;
        color: white;
        border: solid black;
        cursor: pointer;
      }

      @media (max-width: 900px) {
        main {
          flex-direction: column;
        }
        aside, textarea, .preview-container {
          flex: 1 1 100%;
        }
        aside {
          order: -1; 
        }
      }

      @media (max-width: 500px) {
        header {
          flex-direction: column;
          align-items: stretch;
        }
        header input, header button, header label {
          flex: 1 1 100%;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <input id="snippetName" type="text" placeholder="Snippet name" />
      <button id="runBtn">Run</button>
      <button id="saveBtn">Save</button>
      <button id="clearBtn">Clear</button>
      <label><input type="checkbox" id="chunkMode">Chunk Mode</label>
      <label><input type="checkbox" checked id="hideEditorText">Hide Editor Text For Saved Code</label>
      <button id="addChunkBtn" disabled>Add Chunk</button>
      <button id="fullscreenBtn">Fullscreen</button>
      <button id="exitSnippetBtn">Exit Snippet</button>
      <h2>The Epic Viewer</h2>
      <h3>Run code from the textbox, combined chunks, or saved snippets.</h3>
    </header>
    <main>
      <aside>
        <strong>Saved</strong>
        <div id="savedList" class="saved-list"></div>
      </aside>
      <textarea id="editor" spellcheck="false"></textarea>
      <div id="previewContainer" class="preview-container">
        <button id="backBtn" class="back-btn">B</button>
        <iframe id="preview"></iframe>
      </div>
    </main>
    <script>
      const DB_NAME = 'codepad';
      const STORE = 'snippets';
      let chunks = [];

      function openDB() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, 1);
          req.onupgradeneeded = e => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains(STORE)) {
              db.createObjectStore(STORE, { keyPath: 'name' });
            }
          };
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }

      async function putSnippet(obj) {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, 'readwrite');
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
          tx.objectStore(STORE).put(obj);
        });
      }

      async function getSnippet(name) {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const req = db.transaction(STORE).objectStore(STORE).get(name);
          req.onsuccess = () => resolve(req.result || null);
          req.onerror = () => reject(req.error);
        });
      }

      async function deleteSnippet(name) {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, 'readwrite');
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
          tx.objectStore(STORE).delete(name);
        });
      }

      async function listSnippetNames() {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const names = [];
          db.transaction(STORE).objectStore(STORE).openCursor().onsuccess = e => {
            const cursor = e.target.result;
            if (cursor) {
              names.push(cursor.key);
              cursor.continue();
            } else resolve(names);
          };
        });
      }

      const editorEl = document.getElementById('editor');
      const iframeEl = document.getElementById('preview');
      const savedListEl = document.getElementById('savedList');
      const nameEl = document.getElementById('snippetName');
      const previewContainer = document.getElementById('previewContainer');
      const backBtn = document.getElementById('backBtn');
      const chunkModeEl = document.getElementById('chunkMode');
      const addChunkBtn = document.getElementById('addChunkBtn');
      const hideEditorTextEl = document.getElementById('hideEditorText');
      const exitSnippetBtn = document.getElementById('exitSnippetBtn');

      chunkModeEl.addEventListener('change', () => {
        addChunkBtn.disabled = !chunkModeEl.checked;
        if (!chunkModeEl.checked) chunks = [];
      });

      function run() {
        if (chunkModeEl.checked) {
          iframeEl.srcdoc = chunks.concat(editorEl.value).join('');
        } else {
          iframeEl.srcdoc = editorEl.value;
        }
      }

      async function save() {
        const name = (nameEl.value || '').trim();
        if (!name) return alert('Enter a name');

        const combined = chunks.concat(editorEl.value).join('');

        await putSnippet({
          name,
          html: combined,
          chunks: chunks,
          combined: combined
        });

        refreshSavedList();
      }

      async function refreshSavedList() {
        savedListEl.innerHTML = '';
        const names = await listSnippetNames();
        names.forEach(name => {
          const wrapper = document.createElement('div');
          wrapper.className = 'saved-item';

          const btn = document.createElement('button');
          btn.textContent = name;
          btn.onclick = async () => {
            const rec = await getSnippet(name);
            if (rec) {
              nameEl.value = rec.name;
              chunks = rec.chunks || [];
              iframeEl.srcdoc = rec.html || '';
              if (hideEditorTextEl.checked) {
                editorEl.value = '';
              } else {
                editorEl.value = rec.html || '';
              }
              exitSnippetBtn.style.display = 'inline-block'; 
            }
          };

          const delBtn = document.createElement('button');
          delBtn.textContent = 'X';
          delBtn.className = 'delete-btn';
          delBtn.onclick = async (e) => {
            e.stopPropagation();
            if (confirm('Delete saved code?')) {
              await deleteSnippet(name);
              
              refreshSavedList();
             
            }
          };

          wrapper.appendChild(btn);
          wrapper.appendChild(delBtn);
          savedListEl.appendChild(wrapper);
        });
      }

      document.getElementById('runBtn').onclick = run;
      document.getElementById('saveBtn').onclick = save;
      document.getElementById('clearBtn').onclick = () => editorEl.value = '';
      document.getElementById('fullscreenBtn').onclick = () => previewContainer.classList.add('fullscreen');
      backBtn.onclick = () => previewContainer.classList.remove('fullscreen');
      addChunkBtn.onclick = () => {
        chunks.push(editorEl.value);
        editorEl.value = '';
        alert('A Chunk has been added. You now have ' + chunks.length + ' chunks.');
      };

     
      exitSnippetBtn.onclick = () => {
        nameEl.value = '';
        editorEl.value = '';
        iframeEl.srcdoc = '';
        chunks = [];
        exitSnippetBtn.style.display = 'none'; 
      };

      run();
      refreshSavedList();
    </script>
  </body>
</html>
